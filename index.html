---
layout: default
---
<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/syntax.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Devil by wuher</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Devil</h1>
        <h2>REST framework for Django</h2>

        <section id="downloads">
          <a href="https://github.com/wuher/devil/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/wuher/devil/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/wuher/devil" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>Introduction</h3>

        <p>

          Devil aims to be lightweight and simple to use framework for building
          REST APIs in Django. The learning curve should be minimal and you
          don't have to spend too much time going through the documentation
          before you can start using it. Having said that, Devil does offer more
          features for those who are willing to get to know it better.

        </p>
        <p>

          Devil is not a complete application framework in a sense that it does
          not mandate the architecture of your application in any way. It does
          not tell you how you should write your services/controllers/database
          models (nor how to connect them), it only streamlines the way you
          write REST APIs. You can concentrate on just implementing the
          <code>put</code> and <code>get</code> functions, while Devil will take
          care of things like content negotiation, data validation, data
          conversions and providing auto-generated documentation.

        </p>

        <h3>Basic Idea</h3>

        <p>

          Django alreay provides a nice way to <a
          href="https://docs.djangoproject.com/en/dev/topics/http/urls/"> define
          URL schemes</a> for web applications. For example (copied from the
          Django docs):

        </p>

{% highlight python %}
urlpatterns = patterns('',
    (r'^articles/2003/$', 'news.views.special_case_2003'),
    (r'^articles/(\d{4})/$', 'news.views.year_archive'),
    (r'^articles/(\d{4})/(\d{2})/$', 'news.views.month_archive'),
    (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'news.views.article_detail'),
)
{% endhighlight %}

        <p>

          When building a REST API with Devil, you define your URLs exactly like
          this; the only difference is that instead of mapping the URLs into
          views, you map them in your resources. A resource in Devil is an
          instance of a class derived from Devil's <a
          href="https://github.com/wuher/devil/blob/master/devil/resource.py">
          Resource</a>. The derived class should then implement one or more of
          the four REST methods (<code>post, get, put, delete</code>) and
          return appropriate data for example as python dictionary. For example:

        </p>

{% highlight python %}
from django.core.urlresolvers import reverse
from devil import Resource
from devil.http import Response
from devil import errors

class Order(Resource):

    def post(self, data, request, id):
        """ Create a new resource using POST.

        :param data: data provided by the client (converted into dict by devil)
        :param id: optional order id in the url (this is a named parameter in the url regex)
        """
        if id:
            # return 405 to client by raising exception here
            raise errors.MethodNotAllowed()
        # data holds client's data as python dictionary
        newdata = order_repository.add(data)
        # return 201, Location header, and the newly added data (as dict)
        return Response(201, newdata, {
            'Location': '%s%d' % (reverse('order'), order['id'])})

    def get(self, request, id):
        """ Get one order or all orders """
        if id:
            # devil will convert the dictionary into json
            return order_repository.get_one(id)
        else:
            # devil will convert the list of dictionaries into json
            return order_repository.get_all()
{% endhighlight %}

        <p>

          This is similar approach taken by <a
          href="https://bitbucket.org/jespern/django-piston/wiki/Home">
          Piston</a> (a REST framework that Devil was originally inspired by).

        </p>

        <h3>Features</h3>

        <ul>
          <li>Automatic content type negotiation</li>
          <li>Support for authentication</li>
          <li>Flexible access control mechanism</li>
          <li>Ability to formally define representations</li>
          <li>Data validation</li>
          <li>Data marshalling/unmarshalling (dict &lt;-&gt; object)</li>
          <li>Auto-generated documentation of the API</li>
        </ul>

        Up-to-date documentation can be found from the <a
        href="https://github.com/wuher/devil/blob/master/README.markdown">
        README</a>

  </body>
</html>